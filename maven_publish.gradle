//maven-publish 新方式
apply plugin: 'maven-publish'

afterEvaluate{
    publishing {
        publications {
            // Creates a Maven publication called "myPublication".
            myPublication(MavenPublication) {
                afterEvaluate { artifact(tasks.getByName("bundleReleaseAar")) }
                groupId 'com.yuedong.plugin'
                artifactId 'beatuy-plugin'
                version '1.0.0'             // Your package version
                //artifact publishArtifact    //Example: *./target/myJavaClasses.jar*
//                artifact "build/outputs/aar/sdk-release.aar"//aar包的目录

                //带上依赖 ，否则会报错
                pom.withXml {
                    def dependenciesNode = asNode().appendNode('dependencies')

                    def scopes = [configurations.implementation, configurations.api, configurations.compileOnly]
                    if (configurations.hasProperty("debugImplementation")) {
                        scopes.add(configurations.debugImplementation)
                    }
                    if (configurations.hasProperty("releaseImplementation")) {
                        scopes.add(configurations.releaseImplementation)
                    }

                    scopes.each { scope ->
                        scope.allDependencies.each {
                            if (it instanceof ModuleDependency) {
                                boolean isTransitive = ((ModuleDependency) it).transitive
                                if (!isTransitive) {
                                    println "<<<< not transitive dependency: [${it.group}, ${it.name}, ${it.version}]"
                                    return
                                }
                            }

                            if (it.group == "${project.rootProject.name}.libs" || it.version == 'unspecified') {
                                return
                            }

                            if (it.group && it.name && it.version) {
                                def dependencyNode = dependenciesNode.appendNode('dependency')
                                dependencyNode.appendNode('groupId', it.group)
                                dependencyNode.appendNode('artifactId', it.name)
                                dependencyNode.appendNode('version', it.version)
                                dependencyNode.appendNode('scope', scope.name)
                            }
                        }
                    }
                }
            }
        }

        // Repositories *to* which Gradle can publish artifacts
        repositories {
            maven {
                // 对于非 https 的仓库地址，需要使用 allowInsecureProtocol 字段，包括引用该仓库的地方
                //allowInsecureProtocol true
                var codingArtifactsRepoUrl = System.getenv("CODING_ARTIFACTS_REPO_URL") ?: project.property("codingArtifactsRepoUrl")
                var codingArtifactsGradleUsername = System.getenv("CODING_ARTIFACTS_GRADLE_USERNAME") ?: project.property("codingArtifactsGradleUsername")
                var codingArtifactsGradlePassword = System.getenv("CODING_ARTIFACTS_GRADLE_PASSWORD") ?: project.property("codingArtifactsGradlePassword")

                url = codingArtifactsRepoUrl
                credentials {
                    username = codingArtifactsGradleUsername
                    password = codingArtifactsGradlePassword
                }
            }
        }
    }

    //生成文档注释
    task androidJavadocs(type: Javadoc) {
        failOnError = false
        source = android.sourceSets.main.java.srcDirs
        ext.androidJar = "${android.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
        classpath += files(ext.androidJar)
    }
    //将文档打包成jar
    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
        archiveClassifier.set('javadoc')
        from androidJavadocs.destinationDir
    }
    //将源码打包，这一点对kotlin来说很重要，否则业务侧无法看到源码
    task androidSourcesJar(type: Jar) {
        archiveClassifier.set('sources')
        from android.sourceSets.main.java.srcDirs
    }
}
